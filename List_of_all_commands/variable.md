# variable command

## 構文
```
variable name style args ...
```

name = 変数を定義するための名前
style = delete（削除）または index（インデックス）または loop（ループ）または world（ワールド）または universe（ユニバース）または uloop（ユーループ）または string（文字列）または getenv（環境変数取得）または file（ファイル）または atomfile（アトムファイル）または equal（等しい）または atom

```
delete = no args: delete（削除）= 引数なし
index args = one or more strings: index 引数 = 1つ以上の文字列
loop args = N: loop 引数 = N
N = ループのサイズ（整数）、1からNまでのループ
loop args = N pad: loop 引数 = N pad
N = ループのサイズ（整数）、1からNまでのループ
pad = すべての値が同じ長さ（例: 001, 002, ..., 100）
loop args = N1 N2: loop 引数 = N1 N2
N1, N2 = N1からN2までのループ
loop args = N1 N2 pad: loop 引数 = N1 N2 pad
N1, N2 = N1からN2までのループ
pad = すべての値が同じ長さ（例: 050, 051, ..., 100）
world args = one string for each partition of processors: world 引数 = 各プロセッサの区分ごとに1つの文字列
universe args = one or more strings: universe 引数 = 1つ以上の文字列
uloop args = N: uloop 引数 = N
N = ループのサイズ（整数）
uloop args = N pad: uloop 引数 = N pad
N = ループのサイズ（整数）
pad = すべての値が同じ長さ（例: 001, 002, ..., 100）
string arg = one string: string 引数 = 1つの文字列
getenv arg = one string: getenv 引数 = 1つの文字列
file arg = filename: file 引数 = ファイル名
atomfile arg = filename: atomfile 引数 = ファイル名
equal or atom args = one formula containing numbers, thermo keywords, math operations, group functions, atom values and vectors, compute/fix/variable references: equal または atom 引数 = 数字、熱物理キーワード、数学演算、グループ関数、アトム値およびベクトル、計算/修正/変数参照を含む1つの式
数字 = 0.0, 100, -5.4, 2.8e-4 など
定数 = PI
熱物理キーワード = vol, ke など（thermo_style から）
数学演算子 = (), -x, x+y, x-y, x*y, x/y, x^y,
x==y, x!=y, x<y, x<=y, x>y, x>=y, x&&y, x||y, !x
数学関数 = sqrt(x), exp(x), ln(x), log(x), abs(x),
sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y,x),
random(x,y,z), normal(x,y,z), ceil(x), floor(x), round(x)
ramp(x,y), stagger(x,y), logfreq(x,y,z), stride(x,y,z), vdisplace(x,y), swiggle(x,y,z), cwiggle(x,y,z)
グループ関数 = count(group), mass(group), charge(group),
xcm(group,dim), vcm(group,dim), fcm(group,dim),
bound(group,xmin), gyration(group), ke(group),
angmom(group,dim), torque(group,dim),
inertia(group,dimdim), omega(group,dim)
領域関数 = count(group,region), mass(group,region), charge(group,region),
xcm(group,dim,region), vcm(group,dim,region), fcm(group,dim,region),
bound(group,xmin,region), gyration(group,region), ke(group,region),
angmom(group,dim,region), torque(group,dim,region),
inertia(group,dimdim,region), omega(group,dim,region)
特殊関数 = sum(x), min(x), max(x), ave(x), trap(x), gmask(x), rmask(x), grmask(x,y), next(x)
アトム値 = id[i], mass[i], type[i], x[i], y[i], z[i], vx[i], vy[i], vz[i], fx[i], fy[i], fz[i]
アトムベクトル = id, mass, type, x, y, z, vx, vy, vz, fx, fy, fz, omegax, omegay, omegaz, tqx, tqy, tqz, r
計算参照 = c_ID, c_ID[i], c_ID[i][j]
修正参照 = f_ID, f_ID[i], f_ID[i][j]
変数参照 = v_name, v_name[i]
```

## 例
```
variable x index run1 run2 run3 run4 run5 run6 run7 run8
variable LoopVar loop $n
variable beta equal temp/3.0
variable b1 equal x[234]+0.5*vol
variable b1 equal "x[234] + 0.5*vol"
variable b equal xcm(mol1,x)/2.0
variable b equal c_myTemp
variable b atom x*y/vol
variable foo string myfile
variable f file values.txt
variable temp world 300.0 310.0 320.0 ${Tfinal}
variable x universe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
variable x uloop 15 pad
variable x delete
```

## 説明
このコマンドは、1つ以上の文字列を変数名に割り当て、後で入力スクリプトまたはシミュレーション中に評価できるようにします。

変数は複数のコンテキストで役立ちます。変数を定義し、その後入力スクリプト内で参照することで、新しい入力コマンドの一部として使用できます。複数の文字列を格納する変数スタイルの場合、[next]()コマンドを使用して、どの文字列が変数に割り当てられるかをインクリメントできます。equal スタイルの変数は、評価されると単一の数値を生成する式を格納し、この数値は直接出力（[print]()、[fix print]()、[run every]() コマンド参照）または熱物理的な出力（[thermo_style]() コマンド参照）として出力されるか、平均化フィックスの入力として使用されます（[fix ave/time]() コマンド参照）。atom スタイルの変数は、評価されると各アトムに対して1つの数値を生成する式を格納し、この数値はダンプファイルに出力（[dump custom]() コマンド参照）されたり、平均化フィックスの入力として使用されます（[fix ave/spatial]() および [fix ave/atom]() コマンド参照）。atomfile スタイルの変数は、入力スクリプト内でアトムスタイルの変数が使用される場所であればどこでも使用でき、式ではなくファイルからアトムごとの値を取得します。

以下の議論で、変数の「名前」とは、variable コマンドの最初の引数として指定された任意の文字列を指します。この名前には英数字とアンダースコアのみを含むことができます。「文字列」は、続く1つ以上の引数です。「文字列」は、上記の最初の例のように単純なテキストである場合もあれば、2番目の例のように他の変数を含む場合や、3番目の例のように式である場合もあります。「値」は、文字列を評価した結果得られる数値の量です。なお、同じ文字列でも、シミュレーション中の異なるタイミングで評価されると異なる値が生成されることがあります。

[!WARNING]
入力スクリプトの行で、equal または atom スタイルの変数が式を含んで定義されると、その式は即座に評価されて結果が格納されるわけではありません。即時評価については、以下の「変数の即時評価」の議論を参照してください。

[!WARNING]
入力スクリプトで variable コマンドが遭遇し、すでに変数名が指定されている場合、そのコマンドは無視されます。つまり、変数は入力スクリプト内で再定義できません（2つの例外があります、詳細は後述）。これは、入力スクリプトが変数をリセットせずに何度も処理できるようにするためです。[jump]() や [include]() コマンドを参照してください。また、[command- line switch]() -var を使用すると、入力スクリプト内の対応するインデックス変数の設定が上書きされることを意味します。


この規則には2つの例外があります。まず、string、getenv、equal、および atom スタイルの変数は、コマンドが遭遇するたびに再定義されます。これにより、これらのスタイルの変数は入力スクリプト内で何度も再定義できるようになります。ループ内では、equal や atom スタイルの変数に関連する式が、他の変数（例えば $x）を置換する場合に変更されることがあります。

次に、以下に説明するように、next コマンドを使用して文字列リストの最後まで変数を反復した場合、その変数はアクティブな変数リストから削除され、その後の variable コマンドで再定義できるようになります。delete スタイルも同じことを行います。

このマニュアルのセクションでは、入力スクリプトの行で変数名がどのように変数の文字列に置き換えられるかを説明します。変数名は、「x」が1文字であれば $x として参照でき、「LoopVar」が1文字以上であれば ${LoopVar} として参照できます。

以下に説明するように、index、loop、file、universe、および uloop スタイルの変数では、どの文字列が変数に割り当てられるかを next コマンドを使用してインクリメントできます。割り当てるべき文字列がもう無くなると、その変数は使い果たされ、フラグが設定されて、次に入力スクリプトで遭遇した jump コマンドがスキップされるようになります。これにより、入力スクリプト内で繰り返し処理され、その後抜け出すことができる簡単なループを構築することができます。

上記で説明したように、使い果たされた変数は入力スクリプト内で再利用できます。delete スタイルも変数を削除し、使い果たされた場合と同じように、後で入力スクリプト内または入力スクリプトがループされる際に再定義できるようにします。これにより、変数が使い果たされる前に if および jump コマンドを使用してループを抜ける場合に便利です。例えば、以下のようになります：

```
label            loop
variable    a loop 5
print            "A = $a"
if       "$a > 2" then "jump in.script break"
next     a
jump     in.script loop
label            break
variable    a delete
```

index スタイルでは、1つ以上の文字列が指定されます。最初に、1番目の文字列が変数に割り当てられます。[next]() コマンドが変数名と共に使用されるたびに、次の文字列が割り当てられます。すべてのプロセッサは同じ文字列を変数に割り当てます。

単一の文字列値を持つ index スタイルの変数は、[command-line switch]() -var を使用して設定することもできます。詳細については、このセクションを参照してください。

loop スタイルは index スタイルと同じですが、引数として N が1つだけ指定された場合、文字列は1からNまでの整数になります。これにより、入力スクリプトにN個の文字列をリストすることなく、長い実行リスト（例：1000）を生成できます。最初に、文字列「1」が変数に割り当てられます。[next]() コマンドが変数名と共に使用されるたびに、次の文字列（「2」、「3」など）が割り当てられます。すべてのプロセッサは同じ文字列を変数に割り当てます。loop スタイルは、2つの引数 N1 と N2 を指定して設定することもできます。この場合、ループは N1 から N2 まで（両端を含む）実行され、最初に文字列 N1 が変数に割り当てられます。N1 <= N2 かつ N2 >= 0 が必要です。

world スタイルでは、1つ以上の文字列が指定されます。各プロセッサパーティション（または「ワールド」）に対して1つの文字列が必要です。このセクションでは、「-partition」コマンドラインオプションを使用して複数のパーティションで LIGGGHTS(R)-PUBLIC を実行する方法について説明しています。この variable コマンドは、各ワールドに1つの文字列を割り当てます。ワールド内のすべてのプロセッサは同じ文字列を割り当てられます。next コマンドは、ワールドごとに1つの値しかないため、equal スタイルの変数には使用できません。このスタイルの変数は、異なるパーティションで異なるシミュレーションを実行したり、並列テンパリングシミュレーション（temper コマンド参照）を行う際に、異なるパーティションに異なる温度を割り当てる場合に役立ちます。

universe スタイルでは、1つ以上の文字列が指定されます。文字列の数は、プロセッサパーティションまたは「ワールド」の数以上である必要があります。このページでは、「-partition」コマンドラインオプションを使用して、複数のパーティションで LIGGGHTS(R)-PUBLIC を実行する方法について説明しています。この variable コマンドは、最初に各ワールドに1つの文字列を割り当てます。[next]() コマンドがこの変数で使用されると、それを最初に遭遇したプロセッサパーティションに次の利用可能な文字列が割り当てられます。このプロセスは、すべての変数文字列が使い尽くされるまで続きます。したがって、このコマンドは、8つのプロセッサパーティションで50回のシミュレーションを実行するために使用できます。シミュレーションは、利用可能になったパーティションで順番に実行され、すべてが終了するまで続きます。universe スタイルの変数は、LIGGGHTS(R)-PUBLICの実行中にディレクトリ内に作成される「tmp.lammps.variable」と「tmp.lammps.variable.lock」ファイルを使ってインクリメントされます。

uloop スタイルは、universe スタイルと同じですが、文字列は1からNまでの整数です。これにより、入力スクリプトにN個の文字列をリストすることなく、長い実行リスト（例：1000）を生成することができます。


string スタイルでは、単一の文字列が変数に割り当てられます。このスタイルと、単一の文字列を持つ index スタイルとの違いは、string スタイルの変数は再定義できる点です。例えば、入力スクリプト内の後続のコマンドによって再定義されたり、スクリプトがループで再度読み込まれた場合に再定義されます。

getenv スタイルでは、単一の文字列が変数に割り当てられ、この文字列は環境変数の名前である必要があります。変数が評価されると、その環境変数の値が返されます。もしその環境変数が定義されていない場合は、空の文字列が返されます。このスタイルの変数は、環境変数の設定を通じて LIGGGHTS(R)-PUBLIC の入力スクリプトの挙動を調整したり、[shell putenv]() コマンドで事前に保存された情報を取得するために使用できます。なお、環境変数設定はオペレーティングシステムによって保存されるため、[clear]() コマンドを実行しても持続します。

file スタイルでは、変数に割り当てる文字列のリストが含まれるファイル名が指定されます。リストの各文字列は1行ごとに割り当てられます。文字列は数値値でもかまいません。ファイルスタイルの変数が equal スタイル変数で使用される場合、next() 関数によってその文字列が数値に変換され、数式内で使用されます。

file スタイルの変数が定義されると、ファイルが開かれ、最初の行の文字列が読み取られ、変数に保存されます。これにより、変数は何度でも評価でき、その文字列を返します。次の文字列をファイルから読み込む方法は2つあります。1つは [next]() コマンドを使用する方法、もう1つは equal または atom スタイルの変数で使用される next() 関数を使用する方法です。

ファイルの書式設定に関するルールは以下の通りです。コメント文字「#」は行のどこでも使用でき、コメント文字で始まるテキストは削除されます。空白行はスキップされます。非空行の最初の「単語」は、空白で区切られた部分で、変数に割り当てられる「文字列」となります。

atomfile スタイルでは、ファイル名が指定され、このファイルには変数に割り当てる1つ以上の値のセットが含まれています。これらの値は、原子ごとに割り当てられます。ファイルのフォーマットは以下で説明されます。

atomfile スタイルの変数が定義されると、ファイルが開かれ、最初の原子ごとの値のセットが読み込まれ、変数に保存されます。これにより、変数は何度でも評価でき、その値を返します。次の原子ごとの値のセットをファイルから読み込む方法は2つあります。1つは [next]() コマンドを使用する方法、もう1つは atom スタイルの変数で使用される next() 関数を使用する方法です。

ファイルの書式設定に関するルールは以下の通りです。毎回、原子ごとの値のセットが読み込まれると、ファイル内で空でない行が検索されます。コメント文字「#」は行のどこでも使用でき、コメント文字で始まるテキストは削除されます。空白行はスキップされます。非空行の最初の「単語」は、後に続く原子ごとの行数 N を示す数として読み取られます。N はシステム内の原子の総数である場合もあれば、その一部である場合もあります。次の N 行は以下の形式になります。

```
ID value
```

ここで、ID は原子のIDで、value はその原子に割り当てられる原子ごとの数値値です。ID は任意の順序でリストできます。

[!WARNING]原子ごとの行のセットが読み込まれるたびに、すべての原子の値は最初に 0.0 に設定されます。したがって、セットに ID が含まれていない原子の値は 0.0 のままとなります。

equal および atom スタイルでは、単一の文字列が指定され、これは変数が使用されるたびに新たに評価される数式を表します。文字列にスペースを含めたい場合は、ダブルクォーテーションで囲んで、パーサーがそれを単一の引数として扱うようにします。equal スタイルの変数では、この数式はスカラー量を計算し、その計算結果が変数の値となります。atom スタイルの変数では、数式は各原子に対して1つの量を計算し、変数が評価されるたびにその値が割り当てられます。

equal および atom 変数は、入力スクリプトの異なる段階や実行中の異なるタイミングで異なる値を生成することがあります。例えば、equal 変数が fix print コマンドで使用されると、各タイムステップで異なる値が出力される可能性があります。変数を即座に評価し、結果が文字列ではなく変数に保存されるようにしたい場合は、下記の「変数の即時評価」のセクションを参照してください。

next コマンドは equal または atom スタイルの変数では使用できません。なぜなら、これらの変数には1つの文字列しかないからです。

equal または atom 変数の数式には、さまざまな種類の量を含めることができます。各種類の量の構文はシンプルですが、複数の量を入れ子にしたり、さまざまな方法で組み合わせたりして、任意の複雑さの数式を作成できます。例えば、以下のような変数の数式は有効です（ただし少し奇妙ですが）：
```
variable x equal "pe + c_MyTemp / vol^(1/3)"
```

具体的には、数式には以下の要素を含めることができます：数値、サーモキーワード、数学演算子、数学関数、グループ関数、領域関数、原子値、原子ベクトル、計算参照、修正参照、その他の変数への参照。

ほとんどの数式要素はスカラー値を生成しますが、いくつかは原子ごとのベクトル値を生成します。これらは、原子ベクトル、原子ごとのベクトルを表す計算参照、原子ごとのベクトルを表す修正参照、および原子スタイルの変数です。スカラー値に作用する数学関数はスカラー値を生成しますが、原子ごとのベクトルに作用する数学関数は要素ごとに計算を行い、原子ごとのベクトルを生成します。

equal スタイルの変数の数式では、原子ごとのベクトルを生成する数式要素を使用することはできません。atom スタイルの変数の数式では、スカラー値または原子ごとのベクトルを生成する数式要素を使用することができます。atom スタイルの変数は、[group]()を定義する他のコマンド（例えば、[dump]()、[compute]()、[fix]() コマンド）によって評価されます。これらのコマンドが atom スタイルの変数を呼び出すと、その変数の数式評価にはグループ内の原子のみが含まれます。グループに含まれない原子に対しては、変数の値は 0.0 となります。

数式で使用できるサーモキーワードは、[thermo_style custom]() コマンドで定義されたキーワードです。値を計算するために[compute]()コマンド（例えば、「temp」や「press」など）を必要とするサーモキーワードは、thermo_style コマンドによって保存され、呼び出された計算を使用します。これは、[thermo_style]() コマンドで使用するスタイル（およびそのスタイルに関連付けられたサーモキーワード）が、必要な計算を定義し使用している場合にのみ、それらのキーワードを変数で使用できることを意味します。いくつかのサーモキーワードは、間接的に計算を使用して値を計算します（例：エンタルピーキーワードは、temp、pe、および pressure を使用します）。もし変数が入力スクリプト内で直接評価される場合（実行中ではなく）、その時にアクセスされるサーモキーワードの値は現在のものでなければなりません。詳細については、下記の「変数の精度」セクションをご覧ください。

<strong>Math Operators</strong>

数学演算子は通常の方法で記述され、例の中での「x」や「y」は、上記の例のように任意に複雑な数式であっても構いません。この構文では、「x」や「y」はスカラー値や原子ごとのベクトルであり得ます。例えば、「ke/natoms」は2つのスカラー値の割り算であり、「vy+vz」は2つの原子ごとのベクトル（yおよびzの速度）の要素ごとの和です。

演算子は左から右に評価され、通常のCスタイルの優先順位に従います：単項マイナスおよび単項論理NOT演算子「!」が最も高い優先順位で、次に累乗「^」があります。次に乗算と除算、次に加算と減算、次に4つの比較演算子「<」、「<=」、「>」、「>=」、次に「==」および「!=」の2つの比較演算子、さらに論理AND演算子「&&」、最後に論理OR演算子「||」が最も低い優先順位になります。括弧は、数式の1つまたは複数の部分をグループ化したり、デフォルトの優先順位で発生する評価順序とは異なる順序で評価を強制するために使用できます。

[!WARNING]単項マイナスは累乗よりも優先順位が高いため、式「-2^2」は-4ではなく4として評価されます。この規則は、いくつかのプログラミング言語とは互換性がありますが、他の言語とは互換性がない場合があります。前述のように、この動作は括弧を使うことで簡単にオーバーライドできます。式「-(2^2)」は-4として評価されます。

6つの関係演算子は、xとyの間の関係がTRUE（真）かFALSE（偽）かに基づいて1.0または0.0を返します。例えば、式「x<10.0」がatom-style変数の式で使われると、x座標が10.0未満のすべての原子に対して1.0が返され、それ以外の原子には0.0が返されます。論理AND演算子は、両方の引数が非ゼロの場合に1.0を返し、それ以外の場合は0.0を返します。論理OR演算子は、いずれかの引数が非ゼロの場合に1.0を返し、両方の引数がゼロの場合は0.0を返します。論理NOT演算子は、引数が0.0の場合に1.0を返し、それ以外の場合は0.0を返します。

これらの関係演算子と論理演算子は、式内でマスキングや選択操作として使用できます。例えば、ある条件を満たす原子の数を計算するために、1と0の値を返すper-atomベクトルを取り、それを[compute reduce]()コマンドに渡すことができます。

<strong>Math Functions</strong>
数学関数は、キーワードの後に1つ以上の括弧で囲まれた引数「x」、「y」、「z」を指定する形で記述されます。これらの引数は、任意に複雑な式であっても構いません。この構文では、引数はスカラー値またはper-atomベクトルを表すことができます。後者の場合、数学演算はベクトルの各要素に対して実行されます。例えば、「sqrt(natoms)」はスカラーの平方根を計算し、「sqrt(y*z)」は各原子のy座標とz座標の積の平方根を計算したper-atomベクトルを返します。

ほとんどの数学関数は明確な操作を実行します。ln()は自然対数、log()は常用対数（基数10）です。

random(x,y,z)関数は3つの引数を取ります：x = lo、y = hi、z = seed。これはloとhiの間で均等に分布する乱数を生成します。normal(x,y,z)関数も3つの引数を取ります：x = mu、y = sigma、z = seed（10000より大きい素数）。これは平均mu、分散sigma^2のガウス分布に基づく乱数を生成します。どちらの場合も、シードは内部乱数生成器が初めて呼び出される際に使用され、初期化されます。equalスタイル変数の場合、すべてのプロセッサが同じシードを使用し、各プロセッサが同じ乱数列を生成します。atomスタイル変数の場合、指定されたシードを基に各プロセッサにはユニークなシードが作成され、これによりatomスタイル変数をループする各原子に異なる乱数が生成されます。

[!WARNING]内部的には、すべてのequalスタイル変数には1つの乱数生成器、すべてのatomスタイル変数には1つの乱数生成器が使用されます。もし複数の変数（各スタイル）がrandom()またはnormal()数学関数を使用して定義されている場合、内部の乱数生成器は一度だけ初期化されます。これにより、指定されたシードのうち1つのみが生成される乱数列を決定します。


ceil()、floor()、round()関数はCの数学ライブラリにある関数です。ceil()は引数以上の最小の整数を返します。floor()は引数以下の最大の整数を返します。round()は引数に最も近い整数を返します。

ramp(x, y)関数は、実行中の現在のタイムステップに基づいて、指定されたx、yの値の間で線形補間された値を生成します。この補間は次の式に従います：
```
value = x + (y-x) * (timestep-startstep) / (stopstep-startstep)
```

runはstartstepで始まり、stopstepで終わります。startstepとstopstepは、runコマンドのstartおよびstopキーワードを使用して、複数の実行にまたがることができます。これを行う方法については、runコマンドの詳細を参照してください。

stagger(x, y)関数は、現在のタイムステップを使用して、新しいタイムステップを生成します。x, y > 0、およびx > yが必要です。生成されたタイムステップは、x, x+y, 2x, 2x+y, 3x, 3x+y, というように交互に増加します。現在のタイムステップに対して、シーケンスの次のタイムステップが返されます。したがって、stagger(1000, 100)がdump_modify everyコマンドで変数に使用されると、出力タイムステップのシーケンスは次のようになります：
```
100,1000,1100,2000,2100,3000,etc
```

logfreq(x, y, z)関数は、現在のタイムステップを使用して、新しいタイムステップを生成します。x, y, z > 0、そしてy < zが必要です。生成されたタイムステップは、対数的に増加し、次のシーケンスのようになります：x, 2x, 3x,..., yx, zx, 2zx, 3zx,..., yzx, zzx, 2zx*x, などです。現在のタイムステップに対して、シーケンスの次のタイムステップが返されます。したがって、logfreq(100, 4, 10)がdump_modify everyコマンドで変数に使用されると、出力タイムステップのシーケンスは次のようになります：
```
100,200,300,400,1000,2000,3000,4000,10000,20000,etc
```

stride(x, y, z) 関数は、現在のタイムステップを使用して新しいタイムステップを生成します。条件として、𝑥,𝑦≥0x,y≥0、𝑧>0z>0、および 𝑥≤𝑦x≤y が必要です。生成されるタイムステップは、𝑥x から 𝑦y まで、𝑧z の増分で増加します。つまり、次のような数列を生成します: 𝑥,𝑥+𝑧,𝑥+2𝑧,…,𝑦x,x+z,x+2z,…,y。もし 𝑦−𝑥y−x が 𝑧z の倍数でない場合、for ループと同様に、最後の値は 𝑦y を超えないようになります。

現在のタイムステップに対して、次のタイムステップが返されます。

したがって、stride(1000, 2000, 100) が [dump_modify every]() コマンドで変数として使用された場合、次のような出力タイムステップの数列が生成されます:
```
1000,1100,1200, ... ,1900,2000
```

vdisplace(x, y) 関数は 2 つの引数を取ります: 
𝑥=value0 x=value0 と 𝑦=velocity y=velocity。この関数は、実行中の経過時間を使用して、適用された速度による線形変位で値を変更します。変位の計算は、次の式に従います:
```
value = value0 + velocity*(timestep-startstep)*dt
```
ここで、
𝑑
𝑡
dt はタイムステップのサイズです。

実行は startstep から開始されます。startstep は、run コマンドの start キーワードを使用して複数の実行にまたがることができます。この方法の詳細については [run]() コマンドを参照してください。また、[thermo_style]() キーワード elaplong = timestep - startstep も注記として記載されています。

swiggle(x, y, z) と cwiggle(x, y, z) 関数はそれぞれ 3 つの引数を取ります: 
𝑥=value0　x=value0, 𝑦=amplitude　y=amplitude, 
𝑧=period　z=period。これらの関数は、実行中の経過時間を使用して、sin() または cos() 関数によって値を振動させます。振動の計算は、次の式に従います。ここで、$𝜔=frac{2𝜋}{period}$です:

```
value = value0 + Amplitude * sin(omega*(timestep-startstep)*dt)
value = value0 + Amplitude * (1 - cos(omega*(timestep-startstep)*dt))
```
ここで、
𝑑𝑡はタイムステップのサイズです。

実行は startstep から開始されます。startstep は、run コマンドの start キーワードを使用して複数の実行にまたがることができます。この方法の詳細については [run]() コマンドを参照してください。また、[thermo_style]() キーワード elaplong = timestep - startstep も注記として記載されています。

<strong>Group and Region Functions</strong>
グループ関数は、キーワードの後に1つまたは2つの括弧で囲まれた引数を指定する形式です。最初の引数はグループIDです。dim 引数が存在する場合、それは x、y、または z のいずれかです。dir 引数が存在する場合、それは xmin、xmax、ymin、ymax、zmin、または zmax です。dimdim 引数が存在する場合、それは xx、yy、zz、xy、yz、または xz のいずれかです。

以下は、いくつかのグループ関数の説明です：

- count()：グループ内の原子の数。
- mass() と charge()：グループの総質量と電荷。
- xcm() と vcm()：グループの質量中心の位置と速度の成分。
- fcm()：グループに対する総力の成分。
- bound()：グループ内のすべての原子の特定の座標の最小値と最大値。
- gyration()：グループの半径の回転を計算します。定義は compute gyration コマンドで参照できます。
- angmom()：質量中心を中心にしたグループの角運動量の成分。
- torque()：原子にかかる力に基づいて、グループの質量中心を中心にしたトルクの成分。
- inertia()：グループの対称慣性テンソルの6成分のうちの1つを返します。順番は Ixx, Iyy, Izz, Ixy, Iyz, Ixz です。
- omega()：グループの質量中心を中心にした角速度の成分。

リージョン関数は、グループ関数と全く同じ方法で指定されますが、追加の引数としてリージョンIDが必要です。この関数は、グループとリージョンの両方に含まれるすべての原子に対して計算されます。もしグループが「all」であれば、原子がリージョン内にあることが、原子が含まれるための唯一の基準となります。

**Special Functions**

特殊関数は特定の種類の引数を取ります。つまり、引数自体が式であってはいけません。

sum(x)、min(x)、max(x)、ave(x)、およびtrap(x)関数はそれぞれ1つの引数を取ります。この引数は「c_ID」または「c_ID[N]」、「f_ID」または「f_ID[N]」の形式です。最初の2つはcomputeで、後の2つはfixです。参照内のIDは、入力スクリプト内で他の場所で定義されたcomputeまたはfixのIDに置き換える必要があります。computeまたはfixは、グローバルベクトルまたは配列のいずれかを生成する必要があります。もしグローバルベクトルを生成する場合は、"[N]"なしの表記を使用するべきです。グローバル配列を生成する場合は、"[N]"付きの表記を使用し、Nが整数である場合に、グローバル配列のどの列が参照されているかを指定します。

これらの関数は、グローバルベクトルに対して操作を行い、それを単一のスカラー値に縮約します。これは、per-atomおよびローカルベクトルに対して同じ関数を呼び出す[compute reduce]()コマンドの動作と類似しています。

sum() 関数は、すべてのベクトル要素の合計を計算します。min() と max() 関数はそれぞれ最小値と最大値の要素を見つけます。ave() 関数は sum() と同様ですが、結果をベクトルの長さで割ります。trap() 関数は sum() と同じですが、最初と最後の要素には 1/2 の重み係数を掛けて合計を計算します。これは、データのグローバルベクトルに対して台形法則を用いた積分を実行するものです。つまり、x 座標で 1 刻みの間隔で均等に配置された点の集合 (1, V1)、(2, V2)、...、(N, VN) を考えた場合、ここで Vi は長さ N のグローバルベクトル内の値です。これらの点の 1 から N までの積分が trap() です。この関数はタイムステップサイズで適切に正規化すると、[fix ave/correlate]() コマンドで生成されたような時系列データの積分を計算するのに役立ちます。

gmask(x) 関数は、1 つの引数としてグループ ID を取ります。これは atom-style 変数でのみ使用できます。グループに属する原子には 1 を返し、そうでない原子には 0 を返します。

rmask(x) 関数は、1 つの引数として領域 ID を取ります。これは atom-style 変数でのみ使用できます。幾何学的領域に属する原子には 1 を返し、そうでない原子には 0 を返します。

grmask(x, y) 関数は、2 つの引数を取ります。最初はグループ ID、2 番目は領域 ID です。これは atom-style 変数でのみ使用できます。グループと領域の両方に属する原子には 1 を返し、どちらにも属さない原子には 0 を返します。

next(x) 関数は、1 つの引数として変数 ID（「v_foo」ではなく「foo」）を取ります。これはファイルスタイルまたは atomfile スタイルの変数用でなければなりません。next() 関数が呼び出されるたび（つまり、equal-style または atom-style 変数が評価されるたび）、以下の手順が実行されます。

ファイルスタイルの変数の場合、現在ファイルスタイル変数に格納されている文字列値は数値に変換され、関数によって返されます。そして、ファイル内の次の文字列値が読み込まれ、格納されます。注意すべきは、前回ファイルから読み込まれた行が数値でない文字列であった場合、その評価結果は通常 0.0 になるため、これはおそらく望んでいる結果ではないということです。

atomfile-style 変数の場合、現在格納されている各原子の値が関数によって返されます。そして、ファイル内の次の各原子の値のセットが読み込まれ、格納されます。

ファイルスタイルおよび atomfile-style 変数は、入力スクリプトで定義される際にファイルの最初の行や最初の各原子の値のセットを読み込んで格納するため、次回 next() 関数が呼び出される際に返されるのはこれらの値です。もし next() がファイル内の行や値のセットよりも多く呼び出されると、変数は削除されます。これは、next コマンドが操作する方法と同様です。

**Atom Values and Vectors**
Atom値は、1からNまでの単一の整数引数Iを取ります。ここでIは原子IDを意味し、例えば x[243] はIDが243の原子のx座標を使用することを意味します。

原子ベクトルは、各原子ごとに1つの値を生成します。そのため、vx のような参照は、各原子の速度のx成分を変数の評価時に使用することを意味します。なお、他の原子属性も、[compute property/atom]() コマンドを使用して計算された結果を指定することにより、変数の入力として使用できます。

**Compute References**
計算参照は、[compute]() によって計算された量にアクセスします。参照のIDは、入力スクリプトの他の場所で定義された [compute]() のIDに置き換えるべきです。compute コマンドのドキュメントページで説明されているように、計算はグローバル、原子ごと、またはローカルの値を生成できます。変数で使用できるのは、グローバル値と原子ごとの値のみです。また、計算はスカラー、ベクトル、または配列を生成できます。equal スタイルの変数はスカラー値のみを使用できます。これは、グローバルスカラー、またはグローバルまたは原子ごとのベクトルや配列の要素を意味します。atom スタイルの変数は同じスカラー値を使用できますが、原子ごとのベクトル値も使用できます。ベクトル値は、原子ごとのベクトル自体であったり、原子ごとの配列の列であったりします。各計算がどのような値を生成するかについては、個々の計算のドキュメントページを参照してください。

異なる種類の計算参照の例は以下の通りです。参照が何を意味するかは明確であり、計算はグローバルまたは原子ごとの量のみを生成し、両方を生成することはありません。
|||
|--|--|
|c_ID|	global scalar, or per-atom vector|
|c_ID[I]|	Ith element of global vector, or atom I’s value in per-atom vector, or Ith column from per-atom array|
|c_ID[I][J]|	I,J element of global array, or atom I’s Jth value in per-atom array|
計算を含む変数が入力スクリプト内で直接評価される場合（実行中ではなく）、その計算によってアクセスされる値は現在のものでなければなりません。「変数の精度」についての説明を参照してください。

**Fix References**
fix参照は、fixによって計算された量にアクセスします。参照内のIDは、入力スクリプト内で定義されているfixのIDに置き換えるべきです。fixコマンドのドキュメントページで説明されているように、fixはグローバル、各原子、またはローカルの値を生成できます。変数内で使用できるのは、グローバルまたは各原子の値のみです。fixはまた、スカラー、ベクトル、または配列を生成できます。equalスタイルの変数は、スカラー値のみを使用でき、これはグローバルスカラーまたはグローバルまたは各原子のベクトルまたは配列の要素を意味します。atomスタイルの変数は、同じスカラー値を使用できます。また、各原子ベクトル値も使用できます。ベクトル値は、各原子ベクトル自体または各原子配列の列である場合があります。各fixが生成する値の種類については、個別のfixのドキュメントページを参照してください。

fix参照の異なる種類は、上記の表でリストされたcompute参照とまったく同じであり、ここで「c_」は「f_」に置き換えられます。同様に、参照が何を意味するのかに曖昧さはありません。fixは、グローバルまたは各原子の量を生成するだけで、両方を生成することはありません。
|||
|--|--|
|f_ID|	global scalar, or per-atom vector|
|f_ID[I]|	Ith element of global vector, or atom I’s value in per-atom vector, or Ith column from per-atom array|
|f_ID[I][J]|	I,J element of global array, or atom I’s Jth value in per-atom array|

fixを含む変数が入力スクリプト内で直接評価される場合（実行中ではなく）、そのfixによってアクセスされる値は最新であるべきです。詳細は「変数の精度」についての議論を参照してください。

一部のfixは、特定のタイムステップでのみ量を生成します。変数が許可されていないタイムステップでfixにアクセスしようとすると、エラーが発生します。例えば、fix ave/timeコマンドは、100ステップごとに平均値を生成する場合があります。個別のfixコマンドのドキュメントページで、詳細を確認してください。

**Variable References**
変数参照は、他の変数によって保存または計算された量にアクセスし、これによりその変数が評価されます。参照内の名前は、入力スクリプト内で他の場所に定義された変数の名前に置き換えられるべきです。

このドキュメントページで説明されているように、equalスタイルの変数はグローバルなスカラー数値を生成します。atomスタイルおよびatomfileスタイルの変数は、各原子の数値ベクトルを生成します。それ以外の変数は文字列を保存します。equalスタイルの変数の式では、atomスタイルやatomfileスタイル以外の変数スタイルを使用できます（ただし、変数から単一の値のみを添字でアクセスする場合を除く）。文字列を保存する変数が使用される場合、その文字列は数値に変換されます。この場合、文字列が数値でない場合、通常は0.0が生成されることに注意してください。これはおそらく望ましくない結果です。atomスタイルの変数の式では、他のatomスタイルやatomfileスタイルの変数を含む任意のスタイルの変数を使用できます。

異なる種類の変数参照の例は以下の通りです。参照が意味することに関しては曖昧さはなく、変数はグローバルスカラーまたは各原子ベクトルのみを生成し、両方は生成しないためです。
|||
|--|--|
|v_name|	scalar, or per-atom vector|
|v_name[I]|	atom I’s value in per-atom vector|

**Immediate Evaluation of Variables:**
変数を参照する際、先頭に「$」記号（例：$xまたは${abc}）を付ける場合と、「v_」記号（例：v_xまたはv_abc）を付ける場合には違いがあります。前者は、変数コマンドを含むすべての入力スクリプトコマンドで使用できます。入力スクリプトのパーサーは、参照された変数を即座に評価し、その値をコマンドに置き換えます。「Parsing rules」のセクション3.2で説明したように、この目的で名前のない「即時」変数を使用することもできます。たとえば、$((xlo+xhi)/2+sqrt(v_area))のような変数参照は、括弧内の文字列をequalスタイルの変数として評価します。

「v_」を先頭に付けて変数を参照することは、いくつかのコマンド（例：fix ave/spatial、dump custom、またはthermo_styleコマンド）で、変数を実行中に定期的に評価させたい場合に、オプションまたは必須の引数として使われます。また、別の変数を参照したい場合には、変数式内でも使用できます。最初の変数が評価されるたびに、2番目の変数も評価されます。

例えば、入力スクリプトで以下のコマンドを使って「v」変数を定義したとします：
```
variable v equal vol
```
その後、シミュレーションボックスのサイズが変化する実行を行うとします。この場合、最初の体積が「v」変数に割り当てられると思うかもしれませんが、実際にはそうではありません。代わりに、このコマンドは体積を計算する式（「thermo_style」キーワードの「vol」を使用）を変数「v」に割り当てます。もし他のコマンド、例えば「fix ave/time」などで変数「v」を使用した場合、シミュレーション中に現在のボックスの体積が継続的に評価されることになります。

システムの初期体積を保存したい場合は、次のようにできます：
```
variable v equal vol
variable v0 equal $v
```
2番目のコマンドは、「v」を評価させ（初期体積を得る）、その値を「v0」変数に割り当てます。したがって、このコマンド：
```
thermo_style custom step v v0
```
は、実行中に現在の体積と初期体積の両方を定期的に出力します。

変数の式に$記号で始まる変数が含まれている場合、ダブルクォーテーションで囲むことは誤りです。例えば、
```
variable vratio equal "${vfinal}/${v0}"
```
これは、ダブルクォーテーションが変数の置換を防ぐため（入力スクリプトコマンドの解析に関するこのセクションを参照）、後で「vratio」の式が評価される際にエラーが発生します。

**Variable Accuracy:**
明らかに、LIGGGHTS(R)-PUBLICは、変数（equalおよびatomスタイルの変数）を評価する際に、式が正確に評価されるように試みます。式に含まれる内容に応じて、計算（[compute]()）を直接的または間接的に（thermoキーワードを通じて）呼び出したり、以前に計算された計算値にアクセスしたり、または[fix]()によって計算され保存された値にアクセスしたりする必要があります。もし計算が系の圧力やエネルギーを計算するものであれば、これらの量は、変数が値を必要とするタイムステップで、相互原子ポテンシャル（ペア、結合など）の評価中に集計される必要があります。

LIGGGHTS(R)-PUBLICは、[run]()中やエネルギー最小化中にこれらすべてを追跡します。変数を評価しようとした際、正確な値を生成できないタイムステップで評価しようとするとエラーが発生します。例えば、[thermo_style custom]()コマンドが、[fix ave/time]()コマンドで保存された値にアクセスする変数を出力する場合で、thermo出力が生成されるタイムステップがfixコマンドで使用された平均化頻度の倍数でない場合、エラーが発生します。

(1) 変数は正確に評価される場合があります。もし変数が計算（[compute]()）やfixへの参照を含んでおり、これらの値が前回のランの最後のタイムステップで計算されていた場合、それらの値は変数によってアクセスされ使用され、結果は正確になります。

(2) LIGGGHTS(R)-PUBLICは変数を評価できない場合があり、その旨を示すエラーメッセージを生成します。例えば、変数が現在の値ではない計算結果を必要とする場合、LIGGGHTS(R)-PUBLICはエラーを生成します。これは、例えば、そのような変数は最初のランが実行される前に評価できないことを意味します。同様に、ランの間では、変数は前のランの最後のタイムステップで評価されていない限り（例えば熱力学的な出力によって）アクセスすることはできません。

この問題を回避する方法の一つは、変数を使用する前に0タイムステップのランを実行することです。例えば、以下のコマンドは：
```
variable t equal temp
print "Initial temperature = $t"
run 1000
```
この場合、もしこのランが入力スクリプトで指定された最初のランであれば、エラーが発生します。なぜなら、「t」変数の値を生成するためには、温度を計算するための計算（compute）が必要で、その計算を呼び出さなければならないからです。

しかし、以下のコマンドの順序は問題ありません：
``` 
run 0
variable t equal temp
print "Initial temperature = $t"
run 1000
```
この0タイムステップのランは、温度を計算するための計算（compute）を含むさまざまな計算を初期化して呼び出すため、その後のランが完了した後に「t」変数によってアクセスできる現在の値が格納されます。注意すべきは、0タイムステップのランはシステムの状態を変更しないため、その後に続く1000タイムステップのランの入力状態を変更しないということです。また、0タイムステップのランは、変数で使用される計算を実際に使用して呼び出す必要があることにも注意してください（例えば、サーモやダンプの出力を通じて）。これにより、その計算が次のランの変数で使用できるようになります。したがって、計算を定義している変数を表示しようとする場合、その計算が前のランの最後のタイムステップで呼び出されたことを確認するために、熱力学的出力に含めることができます。

計算（compute）とは異なり、フィックス（[fix]()）は、ランの間でその値が変数によってアクセスされてもエラーを生成することはありません。常に変数に何らかの値を返します。ただし、その値が期待通りでない場合があります。たとえば、fix indentコマンドはインデンター（押し込み工具）への力を格納しますが、この力はランが実行されるまで計算されません。そのため、もし変数が最初のランの前にこの値を表示しようとすると、ゼロが出力されます。再度、変数を表示する前に0タイムステップのランを実行することで、期待する効果が得られます。

(3) 変数が不正確に評価される場合があり、LIGGGHTS(R)-PUBLICはこれが発生したことを検出する方法がないことがあります。次のコマンドのシーケンスを考えてみてください：
```
pair_coeff 1 1 1.0 1.0
run 1000
pair_coeff 1 1 1.5 1.0
variable e equal pe
print "Final potential energy = $e"
```
最初のランは、[pair_style]() と [pair_coeff]() コマンドによって定義されたペアポテンシャルの設定を使用して実行されます。ポテンシャルエネルギーは最終タイムステップで評価され、[compute pe]() コマンドによって格納されます（これは [thermo_style]() コマンドによって行われます）。その後、ペア係数が変更され、システムのポテンシャルエネルギーが変更されます。e 変数を通じてポテンシャルエネルギーが表示されると、LIGGGHTS(R)-PUBLICは [compute pe] コマンドによって格納されたポテンシャルエネルギーの値を使用し、それが現在の値だと思い込んで使用します。ラン間でシステムの状態を変更する他のコマンドも多くあり、それにより変数が不正確に評価されることがあります。

この問題に対する解決策は、上記のケース(2)と同じで、つまり変数が評価される前に0タイムステップのランを実行してシステムが最新の状態であることを保証することです。例えば、このコマンドのシーケンスは、変更されたペアポテンシャル係数を反映したポテンシャルエネルギーを表示します：
```
pair_coeff 1 1 1.0 1.0
run 1000
pair_coeff 1 1 1.5 1.0
run 0
variable e equal pe
print "Final potential energy = $e"
```

## 制限事項
任意の式要素（例えば、原子の値など）をグローバル原子IDでインデックス指定するには、原子スタイルがグローバルマッピングを使用してベクトルインデックスを参照できる必要があります。デフォルトでは、分子情報を持つ原子スタイルのみがグローバルマップを作成します。[atom_modify map]() コマンドを使用すると、デフォルトを上書きすることができます。

入力スクリプトで定義されたすべてのユニバースおよびuloopスタイル変数は、同じ数の値を持っていなければなりません。

## 関連コマンド
[next](), [jump](), [include](), temper, [fix print](), [print]()

## デフォルト
None