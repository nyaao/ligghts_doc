# run command

## 構文
```
run N keyword values ...
```

- N = タイムステップ数
- ゼロ個以上のキーワード/値のペアを追加できます。
- キーワード = upto, start, stop, pre, post, every

upto 値 = none  
start 値 = N1  
N1 = 最初の実行が開始されるタイムステップ  
stop 値 = N2  
N2 = 最後の実行が終了するタイムステップ  
pre 値 = no または yes  
post 値 = no または yes  
every 値 = M c1 c2 ...  
M = 実行を M タイムステップのセグメントに分割し、各セグメント間で1つ以上のコマンドを呼び出します。  
c1, c2, ..., cN = 1つ以上の LIGGGHTS(R)-PUBLIC コマンド、各コマンドは引用符で囲まれます。  
c1 = NULL は、コマンドが呼び出されないことを意味します。  

## 例
```
run 10000
run 1000000 upto
run 100 start 0 stop 1000
run 1000 pre no post yes
run 100000 start 0 stop 1000000 every 1000 "print 'Protein Rg = $r'"
run 100000 every 1000 NULL
```

## 説明
指定されたタイムステップ数で動力学を実行または続行します（「run」）。

[run style]()が respa の場合、N は外側ループ（最も大きい）タイムステップを指します。

N = 0 の値は許容されます。この場合、システムの熱力学的特性のみが計算され、タイムステップは進行しません。

upto キーワードは、現在のタイムステップから指定されたタイムステップまで実行することを意味します。例えば、現在のタイムステップが10,000で、「run 100000 upto」が使用されると、さらに90,000タイムステップが実行されます。これは、時間のチャンクを割り当てており、時間制限を超えるとジョブが終了するようなマシンで非常に長い実行を行う際に役立ちます。スクリプトを何度も再起動する必要がある場合（最後の再起動ファイルを読み込む）、同じ run コマンドでスクリプトを繰り返し再起動して、シミュレーションが最終的に完了するまで実行を続けることができます。

start または stop キーワードは、複数のランを実行している場合に使用でき、時間とともに値を変更する fix コマンドが、単一のランだけでなく、全体のランセットにわたって変更を行うようにするために使用します。どの fix が start/stop キーワードとともに使用できるかは、個別の fix に関するドキュメントページで確認してください。

pre および post キーワードは、ランの前後で行われるセットアップ、クリーンアップ、および関連する画面への出力を効率化するために使用できます。これは、多くの短いランを連続して実行したい場合に便利です（例えば、LIGGGHTS(R)-PUBLIC がライブラリとして呼び出され、連続した短い LIGGGHTS(R)-PUBLIC ランの間に他の計算を行う場合など）。

デフォルトでは（pre および post = yes）、LIGGGHTS(R)-PUBLIC は各ランの前に隣接リストを作成し、力を計算し、fix 制約を適用します。また、各ランの後にはタイミング統計を収集して表示します。もしランが前のランの続きであり（つまり設定が変更されていない場合）、初期計算は必要ありません。古い隣接リストや力は有効だからです。そのため、pre が「no」に指定されている場合、初期設定はスキップされますが、熱力学的情報の表示は行われます。最初のランで pre が「no」に設定されている場合、初期設定計算は必須であるため、それは上書きされます。

[!WARNING]2つのランの間で入力スクリプトが設定を変更する場合（例：[fix]()、[dump]()、[compute]()を追加する、または隣接リストパラメータを変更するなど）、初期設定を実行する必要があります。LIGGGHTS(R)-PUBLICはこれをチェックしませんが、この場合、pre noオプションを使用するのはエラーです。

postが「no」に指定された場合、完全なタイミング概要はスキップされ、1行の概要タイミングのみが表示されます。

everyキーワードは、LIGGGHTS(R)-PUBLICの実行を一連の短い実行に分割する手段を提供します。オプションで、1つ以上のLIGGGHTS(R)-PUBLICコマンド（c1、c2、...、cN）が短い実行の間に実行されます。使用する場合、everyキーワードは最後のキーワードでなければならず、可変数の引数を持っています。各引数は単一のLIGGGHTS(R)-PUBLICコマンドであり、各コマンドは引用符で囲む必要があります。これにより、コマンド全体が1つの引数として扱われ、ラン中に複数回実行されるまでコマンド内の変数は評価されません。コマンド自体が引数の1つを引用符で囲む必要がある場合（例えば、[print]()コマンド）、上記の例や以下のように、単一引用符と二重引用符を組み合わせて使用することができます。

everyキーワードは、入力スクリプトで一連の長い実行とコマンドを交互にリストすることを避ける手段です。例えば、[print]()コマンドを呼び出したり、[fix]()を再定義してサーモスタットの温度をリセットしたりすることができます。また、これをLIGGGHTS(R)-PUBLICに追加したコマンドを定期的に実行するために利用することもできます（例えば、ライブラリとして他のコードをラップし、長いLIGGGHTS(R)-PUBLICの実行中に計算を行う）。LIGGGHTS(R)-PUBLICに新しいコマンドを追加する方法についての情報は、このドキュメントのセクションを参照してください。LIGGGHTS(R)-PUBLICを他のコードと結びつける方法についてのアイデアは、このドキュメントのセクションを参照してください。

everyオプションを使用すると、N回の総ステップが、各Mステップの短い実行に分けてシミュレーションされます。各Mステップの実行後に、指定されたコマンドが呼び出されます。もしNULLとして指定されたコマンドが1つだけの場合、コマンドは呼び出されません。したがって、次のような行が存在します：

```
variable q equal x[100]
run 6000 every 2000 "print Coord = $q"
```
は、以下のコマンドと等価です。
```
variable q equal x[100]
run 2000
print Coord = $q
run 2000
print Coord = $q
run 2000
print Coord = $q
```

これは、2000ステップを3回実行し、各実行の間に特定の原子のx座標を出力する動作をします。注意すべきは、変数「$q」がprintコマンドが実行されるたびに新たに評価されることです。

さらに、行継続文字「&」を使用すると、run everyコマンドを複数行に分けて記述することができますが、それでも一つのコマンドとして扱われます。例えば、次のように書けます：

```
run 100000 every 1000 &
  "print 'Minimum value = $a'" &
  "print 'Maximum value = $b'" &
  "print 'Temp = $c'" &
  "print 'Press = $d'"
```

everyキーワードと一緒にpreおよびpostオプションが「no」に設定されている場合、最初の実行ではフルセットアップが行われ、最後の実行でフルタイミングサマリーが表示されますが、途中の実行ではこれらの操作はスキップされます。

[!WARNING]次のように、ループから抜けて実行を終了させるコマンドを指定したいと思うかもしれません：
```
variable t equal temp
run 10000 every 100 "if '$t < 300.0' then 'jump SELF afterrun'"
```
しかし、現在のところこれはうまく動作しません。runコマンドは、各一時停止時にコマンドを1つずつ実行し、その後実行を再開するため、条件に従ってループを抜けることはできません。jumpコマンドの代わりに単純なquitコマンドを使えば、指定した条件が満たされた場合にLIGGGHTS(R)-PUBLICが実行中に終了するようにできます。

## 制限事項
指定されたタイムステップ数Nは符号付き32ビット整数に収まる必要があるため、単一の実行での最大ステップ数はおおよそ20億ステップ（2^31）に制限されます。ただし、連続して実行を行うことで、シミュレーションを任意のステップ数（最大で2^63ステップ）実行することが可能です。

## 関連コマンド
[run_style]()

## デフォルト
オプションのデフォルト値は、start = 現在のタイムステップ、stop = 現在のタイムステップ + N、pre = yes、post = yesです。