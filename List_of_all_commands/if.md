# if command

## 構文
```
if boolean then t1 t2 ... elif boolean f1 f2 ... elif boolean f1 f2 ... else e1 e2 ...
```


- boolean = TRUEまたはFALSEとして評価されるブール式（下記参照）
- then = 必須の単語
- t1,t2,...,tN = 条件が満たされた場合に実行するLIGGGHTS(R)-PUBLICコマンド1つ以上、各コマンドは引用符で囲む
- elif = 任意の単語、複数回使用可能
- f1,f2,...,fN = elif条件が満たされた場合に実行するLIGGGHTS(R)-PUBLICコマンド1つ以上、各コマンドは引用符で囲む（任意の引数）
- else = 任意の引数- 
e1,e2,...,eN = 条件が満たされない場合に実行するLIGGGHTS(R)-PUBLICコマンド1つ以上、各コマンドは引用符で囲む（任意の引数）

## 例
```
if "${steps} > 1000" then quit
if "$x <= $y" then "print X is smaller = $x" else "print Y is smaller = $y"
if "(${eng} > 0.0) || ($n < 1000)" then &
  "timestep 0.005" &
elif $n<10000 &
  "timestep 0.01" &
else &
  "timestep 0.02" &
  "print 'Max step reached'"
if "${eng} > ${eng_previous}" then "jump file1" else "jump file2"
```

## 説明
このコマンドは、入力スクリプト内でif-then-else機能を提供します。ブール式が評価され、その結果はTRUEまたはFALSEになります。上記の例のように、式には変数を含めることができ、これらは[variable]()コマンドによって定義され、式の一部として評価されます。したがって、シミュレーションの現在の状態を反映するユーザー定義の数式を使用して、1つ以上の新しいコマンドを発行できます。

ブール式の結果がTRUEの場合、1つ以上のコマンド（t1, t2, ..., tN）が実行されます。FALSEの場合、次のelifキーワードに関連付けられたブール式が評価され、いずれかがTRUEであれば、そのコマンド（f1, f2, ..., fN）が実行されます。もし、いずれのブール式もTRUEでない場合、elseキーワードに関連付けられたコマンド（e1, e2, ..., eN）が実行されます。elifおよびelseキーワードとそれに関連するコマンドは任意です。それらが指定されていない場合、初期のブール式がFALSEであれば、コマンドは実行されません。

ブール式の構文は以下に説明されています。

各コマンド（t1, f1, e1 など）は、LIGGGHTS(R)-PUBLIC の有効な入力スクリプトコマンドである必要がありますが、[include]() コマンドは許可されていません。コマンドが複数の単語からなる場合、それは引用符で囲む必要があります。そうすることで、単一の引数として扱われます。上記の例のように。

[!WARNING]コマンド自体が引用符で囲まれた引数を必要とする場合（例えば、[print]() コマンド）、その場合、通常通り二重引用符と単一引用符を使用してネストできます。上記および以下の例のように使用します。引数における引用符の使用についての詳細は、マニュアルのセクション "commands 2" を参照してください。ネストは1段階のみ許可されており、ほとんどの使用ケースではこれで十分です。

「&」という行継続文字を使用することで、if コマンドを複数行にわたって記述できますが、それでも1つのコマンドとして扱われますので注意してください。

```
if "$a < $b" then &
  "print 'Minimum value = $a'" &
  "run 1000" &
else &
  'print "Minimum value = $b"' &
  "minimize 0.001 0.001 1000 10000"
```

もし実行するコマンドの一つがquit（無効なLIGGGHTS(R)-PUBLICコマンド、例えば「blah」）である場合、上記の最初の例のように、そのコマンドを実行するとLIGGGHTS(R)-PUBLICは停止します。

また、同じ入力スクリプト内でラベルにジャンプすることで、ifコマンドを使ってループを抜け出すことができます。ループ変数を再利用できるようにするために、関連するループ変数を削除する方法については、variable deleteコマンドを参照してください。

以下は、ifおよびjumpコマンドを使用して、条件が満たされた場合に内側のループを抜け、外側のループを引き続き反復処理する二重ループの例です。

```
label            loopa
variable    a loop 5
  label          loopb
  variable  b loop 5
  print          "A,B = $a,$b"
  run       10000
  if     '$b > 2' then "print 'Jumping to another script'" "jump in.script break"
  next           b
  jump           in.script loopb
label            break
variable    b delete
```

```
next     a
jump     in.script loopa
```

ifおよびelifキーワードのブール式はC言語に似た構文です。各式はifコマンド内で単一の引数として扱われることに注意してください。そのため、式をわかりやすくするために空白を含めたい場合は、式全体を引用符で囲む必要があります。

式は数字から構成されます：
```
0.2, 100, 1.0e20, -15.4, etc
```
およびブール演算子：
```
A == B, A != B, A < B, A <= B, A > B, A >= B, A && B, A || B, !A
```

各AおよびBは、数値または変数参照（例：$aや${abc}）または別のブール式です。

変数が使用される場合、その変数は評価されて式に代入されるときに数値を生成する必要があります。そうでない場合、エラーが発生します。

式は左から右へ評価され、通常のCスタイルの優先順位が適用されます。単項論理NOT演算子「!」が最も優先され、次に4つの関係演算子「<」「<=」「>」「>=」が続きます。次に、2つの関係演算子「==」と「!=」が続き、その後に論理AND演算子「&&」、最後に論理OR演算子「||」が最も優先順位が低くなります。括弧を使用して、式の一部をグループ化したり、デフォルトの優先順位とは異なる評価順序を強制することができます。


6つの関係演算子は、xとyの関係がTRUEかFALSEかに応じて、1.0または0.0を返します。論理AND演算子は、両方の引数がゼロ以外の場合に1.0を返し、そうでない場合は0.0を返します。論理OR演算子は、いずれかの引数がゼロ以外の場合に1.0を返し、そうでない場合は0.0を返します。論理NOT演算子は、引数が0.0の場合に1.0を返し、それ以外の場合は0.0を返します。

全体のブール式は、結果がゼロ以外であればTRUEを返します。結果がゼロの場合、その式の結果はFALSEとなります。

## 制限事項
none

## 関連コマンド
[variable](), [print]()

## デフォルト
none
