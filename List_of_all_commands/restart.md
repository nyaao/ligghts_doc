#

## 構文
```
restart 0
restart N root keyword value ...
restart N file1 file2 keyword value ...
```

- N = 再起動ファイルをこのタイムステップごとに書き込む Nは変数にすることも可能（下記参照）
- root = タイムステップ番号が追加されるファイル名
- file1, file2 = 2つのフルファイル名、書き込み時にこれらのファイル間で切り替え
- ゼロ個以上のキーワード/値ペアを追加できます
- keyword = fileperまたはnfile

fileper引数 = Np  
Np = これだけのプロセッサごとに1つのファイルを書き込む  
nfile引数 = Nf  
Nf = この数だけファイルを書き込む、Nfプロセッサからそれぞれ1つ  

## 例
```
restart 0
restart 1000 poly.restart
restart 1000 restart.*.equil
restart 10000 poly.%.1 poly.%.2
restart v_mystep poly.restart
```

## 説明
バイナリ再起動ファイルを指定されたタイムステップごとに書き出します。これには2つのモードがあり、実行中にいずれか、または両方を使用できます。値が0の場合、再起動ファイルは書き出されません。2つのモードは次の通りです。
1つのファイル名が指定された場合、タイムステップ番号をファイル名に含めた一連のファイル名が作成されます。
2つのファイル名が指定された場合、2つの再起動ファイルのみが作成され、その名前で保存されます。LIGGGHTS(R)-PUBLICは、次々に再起動ファイルを書き込む際に2つの名前を交互に切り替えます。

再起動コマンドは1回だけでなく、1つのファイル名で1回、2つのファイル名で1回、計2回指定することができます。例えば、100000ステップごとに単一のファイル名でアーカイブ用再起動ファイルを出力し、1000ステップごとに2つのファイル名でより頻繁な一時的な再起動ファイルを出力することができます。restart 0を使用すると、両方のモードでの出力が無効になります。

ダンプファイルと同様に、再起動ファイル名には2つのワイルドカード文字を含めることができます。

再起動ファイル名に「*」が含まれている場合、それは現在のタイムステップ値に置き換えられます。この処理は、単一のファイル名を使用する場合のみ認識され、交互に切り替える場合には適用されません。例えば、上記の3番目の例では、次のように再起動ファイルが作成されます：restart.1000.equil、restart.2000.equil など。単一のファイル名が使用され、「*」が含まれていない場合は、タイムステップ値がファイル名に追加されます。例えば、上記の2番目の例では、次のように再起動ファイルが作成されます：poly.restart.1000、poly.restart.2000 など。

再起動ファイル名に「%」文字が含まれている場合、各プロセッサ用に1つのファイルが書き出され、「%」文字はプロセッサID（0からP-1まで）に置き換えられます。さらに、「%」が「base」に置き換えられた追加のファイルも書き出され、これにはグローバル情報が含まれます。例えば、タイムステップ1000で書き出されたファイルは次のようになります：restart.base.1000、restart.0.1000、restart.1.1000、...、restart.P-1.1000。この方法により、ファイルサイズが小さくなり、並列I/Oをサポートする並列マシンでの出力およびその後の入力が高速化されることがあります。下記で説明するfileperおよびnfileオプションを使用すると、書き出されるファイル数を変更できます。

再起動ファイルは、タイムステップがNの倍数であるタイムステップで書き出されますが、実行や最小化の最初のタイムステップでは書き出されません。実行開始前に再起動ファイルを書き出すためには、[write_restart]()コマンドを使用できます。実行の最後のタイムステップでは、Nが倍数でない限り再起動ファイルは書き出されません。最小化が収束した場合、Nが0より大きいと、最小化の最後のタイムステップで再起動ファイルが書き出されます。

Nは数値の代わりに、[equal-style variable]()として指定することもできます。変数はv_nameとして指定され、nameは変数名です。この場合、変数は実行の開始時に評価され、再起動ファイルが書き出される次のタイムステップを決定します。そのタイムステップでは、再度変数が評価され、次のタイムステップが決定されます。したがって、変数はタイムステップ値を返す必要があります。この文脈で使用するのに便利な関数として、stagger()、logfreq()、stride()などの数学関数が[equal-style variable]()の例として参照されます。その他の似たような数学関数も、[equal-style variable]()のオプションとして簡単に追加できます。


例えば、以下のコマンドは1100から1200の間の各ステップで再起動ファイルを作成し、1163ステップで何か問題が発生したシミュレーションをデバッグする際に役立ちます：
```
variable     s equal stride(1100,1200,1)
restart              v_s tmp.restart
```

再起動ファイルに何が保存されているかについては、[read_restart]() コマンドの説明を参照してください。

再起動ファイルは、[read_restart]() コマンドを使用して特定の状態からシミュレーションを再開するために読み込むことができます。ファイルはバイナリ形式で保存されているため、正確に再起動することができますが、別のマシンでは読み取れない場合があります。その場合、[-r command-line switch]()を使用して再起動ファイルをデータファイルに変換できます。

オプションの nfile または fileper キーワードは、指定された再起動ファイル名における「%」ワイルドカード文字と組み合わせて使用できます。上記で説明したように、「%」文字は再起動ファイルを複数の部分に分割し、P 個のプロセッサーごとに1つのファイルを作成します。デフォルトでは、P はシミュレーションが実行されているプロセッサーの数です。nfile または fileper キーワードを使用して、P を小さな値に設定することができ、これは多くのプロセッサーで実行する場合に効率的です。

nfile キーワードは、P を指定された Nf の値に設定します。例えば、Nf = 4 の場合、シミュレーションが100個のプロセッサーで実行されていると、4つのファイルがプロセッサー 0, 25, 50, 75 によって書き込まれます。それぞれは自分自身と次の24個のプロセッサーから情報を収集し、再起動ファイルに書き込みます。

fileper キーワードでは、指定された Np の値が意味するのは、Np 個のプロセッサーごとに1つのファイルを書き込むことです。例えば、Np = 4 の場合、毎回4番目のプロセッサー（0, 4, 8, 12 など）が自分自身と次の3つのプロセッサーから情報を収集し、再起動ファイルに書き込みます。

## 制限事項
none

## 関連コマンド
[write_restart](), [read_restart]()

## デフォルト
```
restart 0
```