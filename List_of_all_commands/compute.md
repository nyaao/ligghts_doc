# compute command

## 構文
```
compute ID group-ID style general_keywords general_values args
```

- ID = 計算のためにユーザーが割り当てた名前
- group-ID = 計算を実行する原子のグループのID
- style = 使用するスタイル名の1つ（下記参照）
- 0個以上の general_keywords / general_values のペアを追加できます。
- general_keywords = update_on_run_end

update_on_run_end の値 = 'yes' または 'no'
yes = 各 run コマンドの最後のステップで計算が更新されます
no = run の終了時に計算は更新されません

args = 特定のスタイルで使用される引数

## 例
```
compute 1 all temp
compute newtemp flow temp/partial 1 1 0
compute 3 all ke/atom update_on_run_end yes
```

## 説明
原子のグループに対して実行される計算を定義します。コンピュータによって計算される量は瞬間的な値であり、これは現在のタイムステップまたはイテレーションでの原子に関する情報から計算されます。ただし、コンピュータはシステムの以前の状態に関する情報を内部的に保存することがあります。コンピュータを定義することは計算を実行することではありません。代わりに、コンピュータは他の LIGGGHTS(R)-PUBLIC コマンドによって必要に応じて呼び出されます。例えば、ダンプファイルの出力を計算するために呼び出されることがあります。さまざまな LIGGGHTS(R)-PUBLIC の出力オプションについては、この["howto" セクション]()で概要を確認できます。多くの出力オプションはコンピュータを使用しています。

LIGGGHTS(R)-PUBLIC で定義されている修正の完全なリストはこのページにあります。

コンピュータの ID は英数字とアンダースコアのみを含むことができます。

コンピュータは、次の3つのスタイルの量のいずれかを計算します：グローバル量、原子ごとの量、またはローカル量。

グローバル量: システム全体の1つ以上の値、例えばシステムの温度です。
原子ごとの量: 各原子に対する1つ以上の値、例えば各原子の運動エネルギーです。指定されたコンピュータグループに属さない原子の原子ごとの値は0.0に設定されます。
ローカル量: 各プロセッサが所有する原子に基づいて計算されますが、原子ごとの値が0個以上ある場合があります。例えば、結合距離のリストなどです。
原子ごとの量を生成するコンピュータには、スタイル名に「atom」が含まれています（例: ke/atom）。ローカル量を生成するコンピュータには、スタイル名に「local」が含まれています（例: bond/local）。「atom」または「local」がスタイル名に含まれないスタイルは、グローバル量を生成します。

なお、1つのコンピュータはグローバル、原子ごとの、またはローカルの量のいずれか1つのみを生成し、複数の量を同時に生成することはありません。

グローバル、原子ごとの、ローカルの量にはそれぞれ3種類の形態があります：単一のスカラー値、値のベクトル、または値の2次元配列です。各コンピュータのドキュメントページでは、そのスタイルと生成する値の種類について説明されています。例えば、原子ごとのベクトルなどです。いくつかのコンピュータは、単一のスタイルで複数の種類の値を生成することがあります。例えば、グローバルスカラーとグローバルベクトルなどです。

コンピュータの量にアクセスする際、以下の括弧記法で参照できます。この場合、ID はコンピュータのIDです。

|||
|--|--|
|c_ID|	entire scalar, vector, or array|
|c_ID[I]|	one element of vector, one column of array|
|c_ID[I][J]|	one element of array|

言い換えれば、1つの括弧を使用すると、量の次元が1回減少します（ベクトル → スカラー、配列 → ベクトル）。2つの括弧を使用すると、次元が2回減少します（配列 → スカラー）。したがって、スカラコンピュータ値を入力として使用するコマンドは、ベクトルや配列の要素も処理することができます。

注意すべき点は、コンピュータの量を使用するコマンドや[variable]()は、通常、すべての種類を許可しないということです。例えば、あるコマンドはスカラではなく、値のベクトルを要求することがあります。このため、コンピュータ量がスカラとベクトルの両方を生成する場合でも、c_ID としてコンピュータ量を参照する際に曖昧さは生じません。さまざまなコマンドの詳細については、ドキュメントページで説明されています。

LIGGGHTS(R)-PUBLIC では、コンピュータによって生成された値をいくつかの方法で使用できます：
- グローバル値は、thermo_style custom コマンドや fix ave/time コマンドを通じて出力できます。また、variable equal や variable atom コマンドで参照することもできます。
- 原子ごとの値は、dump custom コマンドや fix ave/spatial コマンドを通じて出力できます。また、fix ave/atom コマンドで時間平均を取ったり、compute reduce コマンドで集約したりすることもできます。さらに、原子ごとの値は atom-style variable で参照することもできます。
- ローカル値は、compute reduce コマンドで集約したり、fix ave/histo コマンドでヒストグラム化したり、dump local コマンドで出力したりすることができます。

グローバル量を計算するコンピュータの結果は、「集中的な」値または「拡張的な」値のいずれかです。

集中的な値 は、シミュレーション内の原子数に依存しない値を意味します。例えば、温度です。
拡張的な値 は、シミュレーション内の原子数に比例してスケールする値を意味します。例えば、総回転運動エネルギーです。
[Thermodynamic output]()は、システム内の原子数に応じて拡張的な値を正規化します（「thermo_modify norm」設定によります）。集中的な値は正規化されません。もしコンピュータの値が別の方法でアクセスされる場合（例えば、[変数]()を使って）、それが集中的な値か拡張的な値かを確認することが重要です。個々のコンピュータに関する詳細は、ドキュメントページで確認してください。

コンピュータの値は、[run]() コマンドの後に[if]()や[print]()を実行するためにも使用できます。run の外でコンピュータの結果を使用するには、各 run の終了時にその結果を更新する必要があります。コンピュータは一般的にリクエストがあった場合にのみ更新されるため（例えば、ダンプの前など）、この更新を明示的に指定する必要があります。そのためには、すべてのコンピュータで利用可能な update_on_run_end オプションを使用します。関連する値が「yes」に設定されていると、コンピュータは各 run コマンドの終了時に更新され、その後使用することができます。

デフォルトまたはユーザー定義のコンピュータのプロパティは、[compute_modify]() コマンドを使って変更できます。

コンピュータは、[uncompute]() コマンドを使って削除できます。

新しいコンピュータのコードは LIGGGHTS(R)-PUBLIC に追加することができ（マニュアルのこのセクションを参照）、その計算結果は上記で説明したさまざまな方法でアクセスできます。

各コンピュータのスタイルには、それぞれの引数や動作について説明したドキュメントページがあります。LIGGGHTS(R)-PUBLIC に定義されたコンピュータの完全なリストは、このページにあります。

## 制限事項
none

## 関連コマンド
[uncompute](), [compute_modify](), [fix ave/atom](), [fix ave/spatial](), [fix ave/time](), [fix ave/histo]()

## デフォルト
none