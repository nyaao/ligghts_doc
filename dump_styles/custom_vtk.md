# dump custom/vtk command

# 構文
```
dump ID group-ID style N file args
```
- ID = ダンプのためにユーザーが指定した名前
- group-ID = ダンプする原子グループのID
- style = custom/vtk
- N = このタイムステップごとにダンプを行う
- file = ダンプ情報を書き込むファイル名

custom/vtk 引数 = 原子属性のリスト
可能な属性 = id, mol, id_multisphere, type, element, mass, density, rho, p
x, y, z, xs, ys, zs, xu, yu, zu,
xsu, ysu, zsu, ix, iy, iz,
vx, vy, vz, fx, fy, fz,
q, mux, muy, muz, mu,
radius, diameter, omegax, omegay, omegaz,
angmomx, angmomy, angmomz, tqx, tqy, tqz,
c_ID, c_ID[N], f_ID, f_ID[N], v_name

id = 原子ID  
mol = 分子ID  
id_multisphere = マルチスフィア体のID  
type = 原子タイプ  
element = 原子の元素名（dump_modifyコマンドで定義されたもの）  
mass = 原子質量  
x, y, z = スケーリングされていない原子座標  
xs, ys, zs = スケーリングされた原子座標  
xu, yu, zu = 展開された原子座標  
xsu, ysu, zsu = スケーリングされた展開座標  
ix, iy, iz = 原子が存在するボックスのイメージ  
vx, vy, vz = 原子の速度  
fx, fy, fz = 原子にかかる力  
q = 原子の電荷  
mux, muy, muz = 原子の双極子モーメントの方向  
mu = 原子の双極子モーメントの大きさ  
radius, diameter = 球状粒子の半径、直径  
omegax, omegay, omegaz = 球状粒子の角速度  
angmomx, angmomy, angmomz = 非球形粒子の角運動量  
tqx, tqy, tqz = 有限サイズ粒子のトルク  
c_ID = computeによって計算された原子ごとのベクトルID  
c_ID[N] = computeによって計算された原子ごとの配列のN番目の列ID  
f_ID = fixによって計算された原子ごとのベクトルID  
f_ID[N] = fixによって計算された原子ごとの配列のN番目の列ID  
v_name = 原子スタイル変数によって計算された原子ごとのベクトルの名前  
shapex, shapey, shapez = スーパー楕円粒子の半軸  
blockiness1, blockiness2 = スーパー楕円粒子のブロック形状パラメータ  
quat1, quat2, quat3, quat4 = スーパー楕円粒子の四元数成分  

# 例
```
dump dmpvtk all custom/vtk 100 dump*.myforce.vtu id type vx fx
dump dmpvtp flow custom/vtk 100 dump*.displace.pvtp id type c_myD[1] c_myD[2] c_myD[3] v_ke
```

# 説明
原子の量のスナップショットを、Nタイムステップごとに1つ以上のファイルにダンプします。ダンプ出力が書き込まれるタイムステップは、変数によっても制御できます。詳細については、dump_modify everyコマンドを参照してください。

指定されたグループの原子に関する情報のみがダンプされます。dump_modify threshおよびregionコマンドを使用することで、どの原子が含まれるかを変更することもできます。詳細は以下を参照してください。

以下に説明するように、特殊文字「*」とファイル名のサフィックスによって出力の種類が決まります。

[!WARNING]周期的境界条件は、隣接リストが再構築されるタイムステップにのみ適用されるため、ダンプファイルに書き込まれた原子の座標は、シミュレーションボックスの外にわずかに出ている可能性があります。

[!WARNING][dump_modify sort]()オプションが指定されていない限り、ダンプファイルに書き込まれる原子情報の行は、各スナップショットに対して順序が不確定です。これは、単一のプロセッサで実行している場合でも、[atom_modify sort]()オプションがオンの場合に当てはまります（デフォルトでオン）。この場合、原子はシミュレーション中に定期的に空間的に並べ替えられます。また、並列実行の場合にも当てはまり、単一のスナップショットのデータは複数のプロセッサから収集され、それぞれのプロセッサが原子のサブセットを所有しています。

custom/vtk スタイルでは、デフォルトでソートは無効になっています。詳細については、[dump_modify]()のドキュメンテーションページを参照してください。

シミュレーションボックスの次元は、各スナップショットごとに別のファイルに書き込まれます（メインのダンプファイルの形式に応じて、レガシーVTKまたはXML形式）。ファイル名には _boundingBox サフィックスが追加されます。

直交シミュレーションボックスの場合、この情報は直線的なグリッドとして保存されます（レガシー .vtk または .vtr XML形式）。

非直交のトリクリニックシミュレーションボックスは、レガシー .vtk または .vtu XML形式で六面体として保存されます。

custom/vtk スタイルでは、各原子についてダンプファイルに書き込む原子属性のリストを指定できます。可能な属性は上記に記載されています。custom スタイルとは異なり、属性はベクトル成分の順序が正しくなるように並べ替えられ、重複するエントリは削除されます（compute や fix に関しては、正しい順序で指定する必要があります）。

特定のシミュレーションに定義されていない量（例えば、atom style bondにおけるq）を指定することはできません。なぜなら、その原子スタイルでは電荷が割り当てられないからです。ダンプはタイムステップの終了時に行われるため、原子属性にはそのタイムステップ中に適用されたfixの影響が含まれます。可能なdump custom/vtk属性についての説明は以下に記載されています。VTKファイルを書き込むには位置データが必要であるため、「x y z」を明示的に指定する必要はありません。

VTK形式では、1つのファイルにシステムのスナップショットが1つのみ保存されるため、ファイル名にワイルドカード「*」を含める必要があります。そうでないと、ダンプファイルは毎回新しいスナップショットで上書きされます。

ダンプは、タイムステップNの倍数（タイムステップ0を含む）および最小化が収束した場合の最終タイムステップで行われます。つまり、ダンプコマンドが呼び出された後、現在のタイムステップがNの倍数でない場合、最初のタイムステップではダンプは行われません。この動作は、[dump_modify first]()コマンドを使用することで変更可能であり、最小化が任意のタイムステップで終了した後にダンプコマンドが呼び出された場合にも役立ちます。Nは、[dump_modify every]()コマンドを使用することで実行間で変更できます。[dump_modify every]()コマンドでは、変数を使用してダンプファイルが書き込まれるタイムステップの順序を決定することもできます。このモードでは、最初のタイムステップのダンプも[dump_modify first]()コマンドを使用しない限り書き込まれません。

ダンプファイル名には2つのワイルドカード文字を含めることができます。ファイル名に「」文字が含まれている場合、各スナップショットごとに1つのファイルが書き込まれ、「」はタイムステップ値で置き換えられます。例えば、tmp.dump*.vtkはtmp.dump0.vtk、tmp.dump10000.vtk、tmp.dump20000.vtkなどに置き換えられます。なお、[dump_modify pad]()コマンドを使用すると、すべてのタイムステップ番号が同じ長さ（例えば、00010）に揃えられ、いくつかの後処理ツールでダンプファイルを順番に読みやすくすることができます。

出力ファイルを並列で書き込むには、ファイル名が「.pvtu」または「.pvtp」で終わる必要があります。例えば、ファイル名が「data.pvtu」であれば、まさにこの名前の1つのファイルが書き込まれます。このファイルには、プロセッサーデータへのリンクが含まれ、「data_X.vtu」というファイルに書き込まれたプロセッサーデータへのリンクが含まれています。ここで、X（= 0,...,P-1）はファイルを書き込んだプロセッサーのIDです。したがって、ParaViewでデータを可視化するには「data.pvtu」ファイルを開けばよいことになります。並列で出力を行うことは、特に分散型HPCクラスターでは重要であり、実行時間を大幅に短縮することができます。

[!NOTE]従来の「.vtk」ファイル形式は、並列書き込みをサポートしていません。

デフォルトでは、P = プロセッサの数であり、つまりプロセッサごとに1つのファイルが書き込まれますが、Pは[dump_modify]()コマンドのnfileまたはfileperキーワードを使って小さい値に設定できます。これらのオプションは、大規模なプロセッサ数で実行する場合に、ダンプファイルを書き出す最も効率的な方法になることがあります。

「*」文字と並列ファイルタイプを組み合わせて使用すると、多くの小さなダンプファイルが生成されることに注意してください。

dump_modify binaryが使用されると、ダンプファイルはバイナリ形式で書き込まれます。バイナリダンプファイルはテキストバージョンとほぼ同じサイズですが、通常は書き込みがはるかに速くなります。さらに、dump_modify compressorを使用して圧縮されたバイナリデータを書き込むこともできます。圧縮のオプションには以下が含まれます：

```
none: No compression
zlib: Zlib compression
lz4: Lz4 compression (VTK >= 8.0 required)
```

このセクションでは、custom/vtkスタイルの一部として指定できる原子の属性について説明します。

id、mol、id_multisphere、type、element、mass、vx、vy、vz、fx、fy、fz、qの属性は、それぞれ説明の必要がないと思われる基本的なものです。

id は原子のIDです。
mol は分子のIDで、分子系の場合にデータファイルに含まれます。
id_multisphere は、粒子が属するマルチスフィアボディのID（もしあなたのバージョンがマルチスフィアをサポートしていれば）です。
type は原子の種類です。
element は通常、元素の化学名で、[dump_modify element]()コマンドを使用して各タイプに割り当てる必要があります。より一般的には、原子タイプに関連付けたい任意の文字列を指定できます。
mass は原子の質量です。
vx、vy、vz は原子の速度の成分、fx、fy、fz は原子にかかる力の成分、q は原子の電荷です。
原子の座標を出力するためのいくつかのオプションがあります。x、y、z 属性は、原子座標を「スケールなし」で適切な距離[units]()（オングストローム、シグマなど）で書き込むために使用されます。さらに、xs、ys、zs を使用して、座標を「スケールされた」ものとして保存することもできます。この場合、各値は 0.0 から 1.0 の範囲になります。シミュレーションボックスが三斜面（傾いた）であれば、すべての原子座標は依然として 0.0 から 1.0 の範囲内になります。

xu、yu、zu を使用すると、各原子に対するイメージフラグに基づいて座標を「アンラップ」することができます。アンラップとは、原子が周期的境界を1回以上通過した場合、周期的なボックスにラップバックされなかった場合の座標値が出力されることを意味します。xu、yu、zu を使用すると、座標値がスナップショットで表示されるボックスの境界を大きく超える可能性があることに注意してください。

xsu、ysu、zsu を使用するのは xu、yu、zu と似ていますが、アンラップされた座標がボックスサイズでスケーリングされる点が異なります。周期的境界を通過した原子は、対応する座標が1.0増加または減少します。

イメージフラグは、ix、iy、iz 属性を使用して直接出力できます。周期的な次元において、これらのフラグは原子がどのイメージのシミュレーションボックスに含まれているかを指定します。イメージが 0 の場合、それは定義されたボックス内にあることを意味します。値が 2 の場合、真の値を得るためにはボックスの長さを 2 回追加する必要があります。値が -1 の場合、真の値を得るためにはボックスの長さを 1 回引く必要があります。LIGGGHTS(R)-PUBLIC は、シミュレーション中に原子が周期的境界を越える際にこれらのフラグを更新します。

mux、muy、muz 属性は、dipole の原子スタイルで定義された双極子システムに特有のもので、原子の点双極子モーメントの方向を示します。mu 属性は、原子の双極子モーメントの大きさを示します。

radius と diameter 属性は、有限のサイズを持つ球形粒子に特有のもので、sphere の原子スタイルで定義されたものです。スーパー楕円粒子の場合、これらの属性は境界球の半径を示します。

omegax、omegay、omegaz 属性は、角速度を持つ有限のサイズを持つ球形粒子に特有のものです。この量を定義する原子スタイルは、sphere など一部に限られています。

angmomx、angmomy、angmomz 属性は、角運動量を持つ有限のサイズを持つ非球形粒子に特有のものです。この量を定義する原子スタイルは、ellipsoid のみです。

tqx、tqy、tqz 属性は、他の粒子との相互作用により回転トルクを受けることができる有限サイズの粒子に特有のものです。

c_ID と c_ID[N] 属性は、compute によって計算された原子ごとのベクトルや配列を出力するために使用されます。属性内の ID は、入力スクリプト内で事前に定義された実際の compute の ID に置き換える必要があります。詳細については、[compute]() コマンドを参照してください。個々の原子のエネルギー、応力、セントロ対称性パラメータ、配位数を計算する compute があります。

注意すべきは、原子ごとの量ではなく、グローバル量やローカル量を計算する compute は、dump custom/vtk コマンドで出力できないことです。代わりに、グローバル量は [thermo_style custom]() コマンドで出力でき、ローカル量は dump local コマンドで出力できます。

c_ID を属性として使用した場合、compute によって計算された原子ごとのベクトルが出力されます。c_ID[N] を使用した場合、N は 1 から M の範囲内でなければならず、これにより compute によって計算された M 長さの原子ごとの配列の N 番目の列が出力されます。

f_ID と f_ID[N] 属性は、fix によって計算された原子ごとのベクトルや配列を出力するために使用されます。属性内の ID は、入力スクリプトで事前に定義された実際の fix の ID に置き換える必要があります。[fix ave/atom]() コマンドは、原子ごとの量を計算するコマンドの一例です。このコマンドは、任意の [compute]()、[fix]()、またはatom-style [variable]()によって生成された原子ごとの量を時間平均することができ、これにより時間平均された結果をダンプファイルに書き出すことができます。

f_ID を属性として使用した場合、fix によって計算された原子ごとのベクトルが出力されます。f_ID[N] を使用した場合、N は 1 から M の範囲内でなければならず、これにより fix によって計算された M 長さの原子ごとの配列の N 番目の列が出力されます。

v_name 属性は、[variable]()によって計算された原子ごとのベクトルを出力するために使用されます。属性内の名前は、入力スクリプトで事前に定義された実際の変数名に置き換える必要があります。原子スタイル変数のみを参照できます。なぜなら、原子スタイル変数だけが原子ごとの値を生成するからです。原子スタイルの変数は、個々の原子属性、原子ごとの原子属性、熱力学的キーワード、または他の compute、fix、または変数を評価する際に呼び出すことができるため、ダンプファイルに出力する量を作成するための非常に一般的な手段です。

shapex、shapey、shapez、blockiness1、blockiness2、quat1、quat2、quat3、quat4 属性は、スーパー楕円粒子専用であり、したがってこの[atom_atyle]()が必要です。

新しい compute および fix スタイルを LIGGGHTS(R)-PUBLIC に追加して、原子ごとの量を計算し、それをダンプファイルに出力する方法については、マニュアルの[Section_modify]()を参照してください。

# 制限事項
custom/vtk スタイルは、gzipped ダンプファイルの書き込みをサポートしていません。

custom/vtk を使用するには、VTK ライブラリにリンクする必要がありますので、Makefile を適切に調整してください。LIGGGHTS(R)-PUBLIC は、-DLAMMPS_VTK オプションでコンパイルする必要があります。詳細は、ドキュメントの「Making LIGGGHTS(R)-PUBLIC」セクションを参照してください。

custom/vtk ダンプスタイルは、バッファリングやカスタムフォーマット文字列をサポートしていません。

# 関連コマンド
[dump]()、[dump image]()、[dump_modify]()、[undump]()

# デフォルト
デフォルトでは、ファイルは ASCII フォーマットで書き込まれます。ファイル拡張子が .vtk、.vtp、.vtu のいずれでもない場合、レガシー VTK ファイルフォーマットが使用されます。